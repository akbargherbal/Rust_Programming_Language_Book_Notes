The Rust Programming Language
Foreword
Introduction
1. Getting Started
	1.1. Installation
	
		Make sure you installed rust-analyzer plugin both in vs code or intelliJ Idea.
			Very useful for debugging!
			
	1.2. Hello, World!
	1.3. Hello, Cargo!
2. Programming a Guessing Game
	Introdution:
		Keywords:
			let \ match \ use \ fn \ mut \ & \
			
		Concepts:
			crate \ shadowing \ Result type \ ok  \ Err
			
			expression will result in a value; e.g. 5 or True or Err
			Statement is the reverse of expression.
			
			Statements are instructions that do something, they don‚Äôt return a value. Expressions evaluate to a value, they return that value.
			
			Rust is an expression-oriented language. This means that most things are expressions, and evaluate to some kind of value. However, there are also statements.
			
			A function definition is a statement, it does not result in a value. Calling a function is an expression, that expression evaluates to whatever that function call returns.
			
			let num = add(4, 1); // expression that returns a value; 5.

			fn add(x: i32, y:i32) -> i32 {
				x + y
			} // Function definition is a statement that doesn't evaluate to anything.
				On the other hand, calling a function is an expression.
			
			let y = 6; // This is a statement.
			
			########
			Expressions do not include ending semicolons. 
			########




		Goal:
			Generate a random number between 1 - 100.
				Print a congratulatory message.
		Tips:
			cargo doc --open
				open crate documentation in browser.
		Questions:
			Why the current version of the rand crate did not compile; contrary to the old one?
			
	use std::io;
		Import Input/Output from the standard library [std]
		
	fn main() {}
		The entry point to the program.
		
	let mut guess = String::new();
		let:	Create a variable.
		let mut guess:	 explicitly declare the variable guess to be mutible.
		String::new();	A static method; implement method on the class not the instance.
		The :: syntax in the ::new line indicates that new is an associated function (Agains static mehtod).
		
	io::stdin().read_line(&mut guess)
		& indicates that this argument is a reference.
			See Chapter 4 to understand references in Rust.
		.expect("Failed to read line");
			Handling Potential Failure with the Result Type
				See Chapters 6 and 9 for more details on errors.
			If you don‚Äôt call expect, the program will compile, but you‚Äôll get a warning.
	
	Generating a Secret Number
		through rand crate
			modify Cargo.toml file to include rand crate as a dependency.
				under [dependencies]

		use rand::Rng;
			Rng is a trait. See Chapter 10 for more info.
		let secret_number = rand::thread_rng().gen_range(1, 101);
			
		println!("The secret number is: {}", secret_number);
		
	Comparing the Guess to the Secret Number
		std::cmp::Ordering
			Ordering is an enum
			
		match guess.cmp(&secret_number) {
			Ordering::Less => println!("Too small!"),
			Ordering::Greater => println!("Too big!"),
			Ordering::Equal => println!("You win!"),
		}

			A match expression is made up of arms.
				An arm consists of pattern.
			
		let guess: u32 = guess.trim().parse().expect("Please type a number!");
			shadowing: is a solution for converting the type of the variable.
				in this case it was a String and became an integer.
				Shadowing lets us reuse the guess variable name rather than forcing us to create two unique variables, such as guess_str and guess for example.
			trim remove trailing space.
			parse get the number out of the string.
			
			** IMPORTANT:
				Notice we didn't declare the secret_number type; it's the job of the cmp method to infer that.
			expect:
				print error mesage.
			
			
	Allowing Multiple Guesses with Looping
		The loop keyword creates an infinite loop.
		We‚Äôll add that now to give users more chances at guessing the number:
		    loop {
				println!("Please input your guess.");


				match guess.cmp(&secret_number) {
					Ordering::Less => println!("Too small!"),
					Ordering::Greater => println!("Too big!"),
					Ordering::Equal => println!("You win!"),
					
					    }
					}
					
	Handling Invalid Input
		Switching from an expect call to a match expression is how you generally move from crashing on an error to handling the error.
		
			let guess: u32 = match guess.trim().parse() {
				Ok(num) => num,
				Err(_) => continue,
			};
				
		Remember that parse returns a Result type and Result is an enum that has the variants Ok or Err.
		

3. Common Programming Concepts
	Introduction:
		Keywords:
			variables \ basic types \ functions \ comments \ control flow
	Questions:
		Question 3.1.1
		We didn't we use [let] keyword here, why? When is that possible?
	
	Concepts:
		Panic \ Integer Overflow \ Function‚Äôs Signature
		
	3.1. Variables and Mutability
		By default variables are immutable.
			Safety + Concurrency.
		In Rust, the compiler guarantees that when you state that a value won‚Äôt change, it really won‚Äôt change.
		You can make variables mutable by adding [mut] in front of the variable name.
			In addition to allowing this value to change, mut conveys intent to future readers of the code by indicating that other parts of the code will be changing this variable‚Äôs value.
			
			fn main() {
				let mut x = 5;
				println!("The value of x is: {}", x);
				x = 6; // Question 3.1.1 <<<
				println!("The value of x is: {}", x);
				}
		
		Differences Between Variables and Constants:
			First, you aren‚Äôt allowed to use mut with constants. Constants aren‚Äôt just immutable by default‚Äîthey‚Äôre always immutable.
			
			You declare constants using the const keyword instead of the let keyword.
			
			The type of the value must be annotated. // See Next Section [3.2. Data Types].
			
			Constants can be declared in any scope, including the global scope, which makes them useful for values that many parts of code need to know about.
			
			const MAX_POINTS: u32 = 100_000;
			
			Constants are valid for the entire time a program runs, within the scope they were declared in, making them a useful choice for values in your application domain that multiple parts of the program might need to know about, such as the maximum number of points any player of a game is allowed to earn or the speed of light.
			
		Shadowing:
			you can declare a new variable with the same name as a previous variable, and the new variable shadows the previous variable. 
			
			fn main() {
				let x = 5;

				let x = x + 1;

				let x = x * 2;

				println!("The value of x is: {}", x);
			}
			
				// The final value of x is 12.
			
			Shadowing is different from marking a variable as mut, because we‚Äôll get a compile-time error if we accidentally try to reassign to this variable without using the let keyword. 
			
			Shadowing thus spares us from having to come up with different names, such as spaces_str and spaces_num; instead, we can reuse the simpler spaces name. 
			

	3.2. Data Types
		Keep in mind that Rust is a statically typed language, which means that it must know the types of all variables at compile time. 
		
		Two data type subsets: 
			scalar
				Integers
					[u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize]
					(_) underscore can be used as a sperator 1_054_00
					default i32
				Floating-Point
					[f32, f64]
					default f64
				Booleans
					[true, false]
				Characters
					declared using single quote 'some_string'
					single character ... not more than one UTF-8!
					
					fn main() {
						let c = 'z';
						let z = '‚Ñ§';
						let heart_eyed_cat = 'üòª';
					}

			compound
				Compound types can group multiple values into one type. Rust has two primitive compound types: tuples and arrays.
				
				The Tuple Type:
					A tuple is a general way of grouping together a number of values with a variety of types into one compound type.
					
					Tuples have a fixed length: once declared, they cannot grow or shrink in size.
					
					We create a tuple by writing a comma-separated list of values inside parentheses.
					
					Each position in the tuple has a type, and the types of the different values in the tuple don‚Äôt have to be the same.
					
					fn main() {
						let tup: (i32, f64, u8) = (500, 6.4, 1);
					}
						
					fn main() {
						let tup = (500, 6.4, 1);
						let (x, y, z) = tup;
						println!("The value of y is: {}", y);
					}
					
					In addition to destructuring through pattern matching, we can access a tuple element directly by using a period (.) followed by the index of the value we want to access. 
					
					fn main() {
						let x: (i32, f64, u8) = (500, 6.4, 1);
						let five_hundred = x.0;
						let six_point_four = x.1;
						let one = x.2;
					}
					

				The Array Type:
					Unlike a tuple, every element of an array must have the same type.
					
					Arrays in Rust are different from arrays in some other languages because arrays in Rust have a fixed length, like tuples.
					
					In Rust, the values going into an array are written as a comma-separated list inside square brackets:
					
					fn main() {
						let a = [1, 2, 3, 4, 5];
					}
					
					Arrays are useful when you want your data allocated on the stack rather than the heap,
					
					or when you want to ensure you always have a fixed number of elements.
					
					An array isn‚Äôt as flexible as the vector type, though. A vector is a similar collection type provided by the standard library that is allowed to grow or shrink in size.
					
					 If you‚Äôre unsure whether to use an array or a vector, you should probably use a vector. 
					 
					 Chapter 8 discusses vectors in more detail.
					
					An example of when you might want to use an array rather than a vector is in a program that needs to know the names of the months of the year. 
					
					fn main() {
						let months = ["January", "February", "March", "April", "May", "June", "July",
						"August", "September", "October", "November", "December"];
					}
					
					You would write an array‚Äôs type by using square brackets, and within the brackets include the type of each element, a semicolon, and then the number of elements in the array, like so:
					
					fn main() {
						let a: [i32; 5] = [1, 2, 3, 4, 5];
					}
					
						Here, i32 is the type of each element. After the semicolon, the number 5 indicates the array contains five elements.
					
					fn main() {
						let a = [3; 5];
					}
					
						The array named a will contain 5 elements that will all be set to the value 3 initially. This is the same as writing let a = [3, 3, 3, 3, 3]; but in a more concise way.
						
					An array is a single chunk of memory allocated on the stack. You can access elements of an array using indexing, like this:
					
					fn main() {
						let a = [1, 2, 3, 4, 5];
						let first = a[0];
						let second = a[1];
						}
				

	3.3. Functions
		[main] function is the entry point of [many] programs in Rust.
		
		functions are declared using [fn] keyword.
		
		snake_case convention is used to name functions.
			
		fn main() {
			println!("Hello, world!");

			another_function();
		}

		fn another_function() {
			println!("Another function.");
		}
		
		Function definitions in Rust start with fn and have a set of parentheses after the function name.
		
		The curly brackets tell the compiler where the function body begins and ends.
		
		Rust doesn‚Äôt care where you define your functions, only that they‚Äôre defined somewhere.
		
		Function Parameters:
			Functions can also be defined to have parameters, which are special variables that are part of a function‚Äôs signature.
			
			When a function has parameters, you can provide it with concrete values for those parameters.
				Technically, the concrete values are called arguments.
				
			fn main() {
				another_function(5);
			}

			fn another_function(x: i32) {
				println!("The value of x is: {}", x);
			}
			
			##########
			In function signatures, you must declare the type of each parameter.
			##########
			
		Function Bodies Contain Statements and Expressions:
			Basic stuff.
			
		Functions with Return Values:
			You can return early from a function by using the return keyword and specifying a value, but most functions return the last expression implicitly.
			
			fn main() {
				let x = plus_one(5);

				println!("The value of x is: {}", x);
				}

			fn plus_one(x: i32) -> i32 {
				x + 1
			}

	3.4. Comments
		Double Slash // is the basic type of comments.
			// Double slash can be used on at the beginning of the line or at the end.
		
	3.5. Control Flow
		if expressions:
			fn main() {
				let number = 3;

				if number < 5 {
					println!("condition was true");
				}
				else {
					println!("condition was false");
				}
			}
			
			Blocks of code associated with the conditions in if expressions are sometimes called arms, just like the arms in match expressions.
			
			Optionally, we can also include an else expression.
			
			If you don‚Äôt provide an else expression and the condition is false, the program will just skip the if block and move on to the next bit of code.
			
			It‚Äôs also worth noting that the condition in this code must be a bool.
				Compare that to other programming languages; like python!
				
		Handling Multiple Conditions with else if:
			fn main() {
				let number = 6;

				if number % 4 == 0 {
					println!("number is divisible by 4");
				} 
				else if number % 3 == 0 {
					println!("number is divisible by 3");
				} // This is the condition that will be executed.
				else if number % 2 == 0 {
					println!("number is divisible by 2");
				} 
				else {
					println!("number is not divisible by 4, 3, or 2");
				}
			}
			
			Rust only executes the block for the first true condition, and once it finds one, it doesn‚Äôt even check the rest.
			
			Using too many else if expressions can clutter your code, so if you have more than one, you might want to refactor your code. Chapter 6 describes a powerful Rust branching construct called match for these cases.
		
		Using if in a let Statement:
			Because if is an expression, we can use it on the right side of a let statement:
				fn main() {
					let condition = true;
					let number = if condition { 5 } else { 6 };

					println!("The value of number is: {}", number);
				}
				
					Remember that blocks of code evaluate to the last expression in them, and numbers by themselves are also expressions.
					
			

		Repetition with Loops:
			Rust has three kinds of loops: 
				loop
				while
				for
			
		Returning Values from Loops:
			Using break expression.
			fn main() {
				let mut counter = 0;

				let result = loop {
					counter += 1;

					if counter == 10 {
						break counter * 2;
					}
				};

				println!("The result is {}", result);
			}

		Conditional Loops with while:
			fn main() {
				let mut number = 3;

				while number != 0 {
					println!("{}!", number);

					number -= 1;
				}

				println!("LIFTOFF!!!");
			}
		
		Looping Through a Collection with for:
		
			fn main() {
				let a = [10, 20, 30, 40, 50];

				for element in a.iter() {
					println!("the value is: {}", element);
				}
			}

		
4. Understanding Ownership
	Ownership is Rust‚Äôs most unique feature, and it enables Rust to make memory safety guarantees without needing a garbage collector. 
	
	Also discussed:
		borrowing \ slices \ memory management \ references \ data races \ mutable references \ lifetime \
	
	4.1. What is Ownership?
		Rust‚Äôs central feature is ownership. 
			Straightforward to explain.
			Yet deep implications.
		
		Memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. 
		
		Stack vs. Heap:
			In a systems programming language like Rust, whether a value is on the stack or the heap has more of an effect on how the language behaves and why you have to make certain decisions. 
			
			Both the stack and the heap are parts of memory that are available to your code to use at runtime, but they are structured in different ways. 
			
			The stack stores values in the order it gets them and removes the values in the opposite order. This is referred to as last in, first out.
				Stack ... like a stack of plates LIFO.
			
				Adding data is called pushing onto the stack, and removing data is called popping off the stack.
				
				All data stored on the stack must have a known, fixed size.
			
			Data with an unknown size at compile time or a size that might change must be stored on the heap instead.
			
			The heap is less organized: when you put data on the heap, you request a certain amount of space. 
			
			The memory allocator finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer, which is the address of that location. 
			
				This process is called allocating on the heap and is sometimes abbreviated as just allocating. 
				
			Think of being seated at a restaurant. When you enter, you state the number of people in your group, and the staff finds an empty table that fits everyone and leads you there.
			
				 If someone in your group comes late, they can ask where you‚Äôve been seated to find you. [POINTER].
			
			Pushing to the stack is faster than allocating on the heap because the allocator never has to search for a place to store new data; that location is always at the top of the stack.
			
			Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. 
			
		Ownership Rules:
			Each value in Rust has a variable that‚Äôs called its owner.
			There can only be one owner at a time.
			When the owner goes out of scope, the value will be dropped.
	
		Variable Scope:
			A scope is the range within a program for which an item is valid.

			fn main() {
				{                      // s is not valid here, it‚Äôs not yet declared
					let s = "hello";   // s is valid from this point forward

					// do stuff with s
				}                      // this scope is now over, and s is no longer valid
			}
			
			There are two important points in time here:
				When s comes into scope, it is valid.
				It remains valid until it goes out of scope.
				
				At this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. 
				
				Now we‚Äôll build on top of this understanding by introducing the String type.
			
		The String Type:
			String type is allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time.
			
			You can create a String from a string literal using the from function, like so:
			
			fn main() {
				let s = String::from("hello");
			}
			
			
			fn main() {
				let mut s = String::from("hello");

				s.push_str(", world!"); // push_str() appends a literal to a String

				println!("{}", s); // This will print `hello, world!`
			}
			
			So, what‚Äôs the difference here? Why can String be mutated but literals cannot? The difference is how these two types deal with memory.
			
		Memory and Allocation:
			In the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable.
			
			This is why string literals are fast and efficient. But these properties only come from the string literal‚Äôs immutability. 
			
			With the String type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:
			
				The memory must be requested from the memory allocator at runtime.
				
					That first part is done by us: when we call String::from, its implementation requests the memory it needs. This is pretty much universal in programming languages.

				We need a way of returning this memory to the allocator when we‚Äôre done with our String.
					Rust takes a different path from other programming languages that use Garbage Collector (GC),  the memory is automatically returned once the variable that owns it goes out of scope. Here‚Äôs a version of our scope example from Listing 4-1 using a String instead of a string literal:


				fn main() {
					{
						let s = String::from("hello"); // s is valid from this point forward

						// do stuff with s
					}                                  // this scope is now over, and s is no
													   // longer valid
				}

			When a variable goes out of scope, Rust automatically calls the drop function and cleans up the heap memory for that variable. 
			

			
		Ways Variables and Data Interact: Clone
			If we do want to deeply copy the heap data of the String, not just the stack data, we can use a common method called clone.
			
			fn main() {
				let s1 = String::from("hello");
				let s2 = s1.clone();

				println!("s1 = {}, s2 = {}", s1, s2);
			}

			When you see a call to clone, you know that some arbitrary code is being executed and that code may be expensive. It‚Äôs a visual indicator that something different is going on.
			
		Stack-Only Data: Copy
			Rust has a special annotation called the Copy trait that we can place on types like integers that are stored on the stack
			
		So what types implement the Copy trait? 
			All the integer types, such as u32.
			The Boolean type, bool, with values true and false.
			All the floating point types, such as f64.
			The character type, char.
			Tuples, if they only contain types that also implement Copy.
			
		Ownership and Functions:
			For the following code; try printing the value of s and x. Why do we get a compile error when we print s, but not x?
			
			fn main() {
				let s = String::from("hello");  // s comes into scope

				takes_ownership(s);             // s's value moves into the function...
												// ... and so is no longer valid here

				let x = 5;                      // x comes into scope

				makes_copy(x);                  // x would move into the function,
												// but i32 is Copy, so it‚Äôs okay to still
												// use x afterward

			} // Here, x goes out of scope, then s. But because s's value was moved, nothing
			  // special happens.

			fn takes_ownership(some_string: String) { // some_string comes into scope
				println!("{}", some_string);
			} // Here, some_string goes out of scope and `drop` is called. The backing
			  // memory is freed.

			fn makes_copy(some_integer: i32) { // some_integer comes into scope
				println!("{}", some_integer);
			} // Here, some_integer goes out of scope. Nothing special happens.

			If we print s we get the following error for s which is of the String type:
				[value borrowed here after move]
			But we don't get that error for x which is of the integer type.
			
		Return Values and Scope
			# The motive behind references & borrowing it seems. See the next section.

	4.2. References and Borrowing:
		& Symbole (Ampersand) denotes references (a pointer in other languages).
		These ampersands are references, and they allow you to refer to some value without taking ownership of it.
		
		fn main() {
			let s1 = String::from("hello");

			let s2 = &s1;

			println!("s1 = {}, s2 = {}", s1, s2);
			// s1 is the owner of the data "hello".
			// s2 is a reference, that referes to / points to the same data.
		}
		
		
		Note: The opposite of referencing by using & is dereferencing, which is accomplished with the dereference operator, *. We‚Äôll see some uses of the dereference operator in Chapter 8 and discuss details of dereferencing in Chapter 15.
		
							& vs * ---- [Referencing (7) vs Dereferencing (8)]
		fn main() {
			let s1 = String::from("hello");

			let len = calculate_length(&s1);

			println!("The length of '{}' is {}.", s1, len);
		}

		fn calculate_length(s: &String) -> usize {
			s.len()
		}
		
			The &s1 syntax lets us create a reference that refers to the value of s1 but does not own it. 
			
			Because it does not own it, the value it points to will not be dropped when the reference goes out of scope.
			
			The scope in which the variable s is valid is the same as any function parameter‚Äôs scope, but we don‚Äôt drop what the reference points to when it goes out of scope because we don‚Äôt have ownership.
			
			When functions have references as parameters instead of the actual values, we won‚Äôt need to return the values in order to give back ownership, because we never had ownership.
			
			We call having references as function parameters borrowing.
			
			Watch the following video from Garry Explains YT channel:
				https://youtu.be/79phqVpE7cU
				
			Each bit of data, e.g. "hello", has an owner.
			And, there can be only one.
		
		
			We call having references as function parameters borrowing. As in real life, if a person owns something, you can borrow it from them. When you‚Äôre done, you have to give it back.
			
			** IMPORTANT:
			Just as variables are immutable by default, so are references. We‚Äôre not allowed to modify something we have a reference to.


		Mutable References:
			Mutable references have one big restriction: you can have only one mutable reference to a particular piece of data in a particular scope. 
			
			The benefit of having this restriction is that Rust can prevent data races at compile time. A data race is similar to a race condition and happens when these three behaviors occur:

				*	Two or more pointers access the same data at the same time.
				*	At least one of the pointers is being used to write to the data.
				*	There‚Äôs no mechanism being used to synchronize access to the data.
				
			As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not simultaneous ones:
			
			fn main() {
				let mut s = String::from("hello");

				{
					let r1 = &mut s;
				} // r1 goes out of scope here, so we can make a new reference with no problems.

				let r2 = &mut s;
			}
		
			We also cannot have a mutable reference while we have an immutable one.

			For instance, this code will compile because the last usage of the immutable references occurs before the mutable reference is introduced:
				
				fn main() {
					let mut s = String::from("hello");

					let r1 = &s; // no problem
					let r2 = &s; // no problem
					println!("{} and {}", r1, r2);
					// r1 and r2 are no longer used after this point

					let r3 = &mut s; // no problem
					println!("{}", r3);
				}

				The scopes of the immutable references r1 and r2 end after the println! where they are last used, which is before the mutable reference r3 is created. These scopes don‚Äôt overlap, so this code is allowed.


		Dangling References:
			In Rust, by contrast to other low-level languages, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.

		The Rules of References:
			At any given time, you can have either one mutable reference or any number of immutable references.
			References must always be valid.

		
	4.3. The Slice Type
		Slice is a a data type that does not have ownership.
		Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection.
		
		String Slices:
			A string slice is a reference to part of a String, and it looks like this:
				fn main() {
					let s = String::from("hello world");

					let hello = &s[0..5];
					let world = &s[6..11];
				}



		
5. Using Structs to Structure Related Data
	5.1. Defining and Instantiating Structs
	5.2. An Example Program Using Structs
	5.3. Method Syntax
6. Enums and Pattern Matching
	6.1. Defining an Enum
	6.2. The match Control Flow Operator
	6.3. Concise Control Flow with if let
7. Managing Growing Projects with Packages, Crates, and Modules
	7.1. Packages and Crates
	7.2. Defining Modules to Control Scope and Privacy
	7.3. Paths for Referring to an Item in the Module Tree
	7.4. Bringing Paths Into Scope with the use Keyword
	7.5. Separating Modules into Different Files
8. Common Collections
	8.1. Storing Lists of Values with Vectors
	8.2. Storing UTF-8 Encoded Text with Strings
	8.3. Storing Keys with Associated Values in Hash Maps
9. Error Handling
	9.1. Unrecoverable Errors with panic!
	9.2. Recoverable Errors with Result
	9.3. To panic! or Not To panic!
10. Generic Types, Traits, and Lifetimes
	10.1. Generic Data Types
	10.2. Traits: Defining Shared Behavior
	10.3. Validating References with Lifetimes
11. Writing Automated Tests
	11.1. How to Write Tests
	11.2. Controlling How Tests Are Run
	11.3. Test Organization
12. An I/O Project: Building a Command Line Program
	12.1. Accepting Command Line Arguments
	12.2. Reading a File
	12.3. Refactoring to Improve Modularity and Error Handling
	12.4. Developing the Library‚Äôs Functionality with Test Driven Development
	12.5. Working with Environment Variables
	12.6. Writing Error Messages to Standard Error Instead of Standard Output
13. Functional Language Features: Iterators and Closures
	13.1. Closures: Anonymous Functions that Can Capture Their Environment
	13.2. Processing a Series of Items with Iterators
	13.3. Improving Our I/O Project
	13.4. Comparing Performance: Loops vs. Iterators
14. More about Cargo and Crates.io
	14.1. Customizing Builds with Release Profiles
	14.2. Publishing a Crate to Crates.io
	14.3. Cargo Workspaces
	14.4. Installing Binaries from Crates.io with cargo install
	14.5. Extending Cargo with Custom Commands
15. Smart Pointers
	15.1. Using Box<T> to Point to Data on the Heap
	15.2. Treating Smart Pointers Like Regular References with the Deref Trait
	15.3. Running Code on Cleanup with the Drop Trait
	15.4. Rc<T>, the Reference Counted Smart Pointer
	15.5. RefCell<T> and the Interior Mutability Pattern
	15.6. Reference Cycles Can Leak Memory
16. Fearless Concurrency
	16.1. Using Threads to Run Code Simultaneously
	16.2. Using Message Passing to Transfer Data Between Threads
	16.3. Shared-State Concurrency
	16.4. Extensible Concurrency with the Sync and Send Traits
17. Object Oriented Programming Features of Rust
	17.1. Characteristics of Object-Oriented Languages
	17.2. Using Trait Objects That Allow for Values of Different Types
	17.3. Implementing an Object-Oriented Design Pattern
18. Patterns and Matching
	18.1. All the Places Patterns Can Be Used
	18.2. Refutability: Whether a Pattern Might Fail to Match
	18.3. Pattern Syntax
19. Advanced Features
	19.1. Unsafe Rust
	19.2. Advanced Traits
	19.3. Advanced Types
	19.4. Advanced Functions and Closures
	19.5. Macros
20. Final Project: Building a Multithreaded Web Server
	20.1. Building a Single-Threaded Web Server
	20.2. Turning Our Single-Threaded Server into a Multithreaded Server
	20.3. Graceful Shutdown and Cleanup
21. Appendix
	21.1. A - Keywords
	21.2. B - Operators and Symbols
	21.3. C - Derivable Traits
	21.4. D - Useful Development Tools
	21.5. E - Editions
	21.6. F - Translations of the Book
	21.7. G - How Rust is Made and ‚ÄúNightly Rust‚Äù