The Rust Programming Language
Foreword
Introduction
1. Getting Started
	1.1. Installation
	
		Make sure you installed rust-analyzer plugin both in vs code or intelliJ Idea.
			Very useful for debugging!
			
	1.2. Hello, World!
	1.3. Hello, Cargo!
2. Programming a Guessing Game
	Introdution:
		Keywords:
			let \ match \ use \ fn \ mut \ & \
			
		Concepts:
			crate \ shadowing \ Result type \ ok  \ Err
			
			expression will result in a value; e.g. 5 or True or Err
			Statement is the reverse of expression.
			
			Statements are instructions that do something, they don’t return a value. Expressions evaluate to a value, they return that value.
			
			Rust is an expression-oriented language. This means that most things are expressions, and evaluate to some kind of value. However, there are also statements.
			
			A function definition is a statement, it does not result in a value. Calling a function is an expression, that expression evaluates to whatever that function call returns.
			
			let num = add(4, 1); // expression that returns a value; 5.

			fn add(x: i32, y:i32) -> i32 {
				x + y
			} // Function definition is a statement that doesn't evaluate to anything.
				On the other hand, calling a function is an expression.
			
			let y = 6; // This is a statement.
			
			########
			Expressions do not include ending semicolons. 
			########




		Goal:
			Generate a random number between 1 - 100.
				Print a congratulatory message.
		Tips:
			cargo doc --open
				open crate documentation in browser.
		Questions:
			Why the current version of the rand crate did not compile; contrary to the old one?
			
	use std::io;
		Import Input/Output from the standard library [std]
		
	fn main() {}
		The entry point to the program.
		
	let mut guess = String::new();
		let:	Create a variable.
		let mut guess:	 explicitly declare the variable guess to be mutible.
		String::new();	A static method; implement method on the class not the instance.
		The :: syntax in the ::new line indicates that new is an associated function (Agains static mehtod).
		
	io::stdin().read_line(&mut guess)
		& indicates that this argument is a reference.
			See Chapter 4 to understand references in Rust.
		.expect("Failed to read line");
			Handling Potential Failure with the Result Type
				See Chapters 6 and 9 for more details on errors.
			If you don’t call expect, the program will compile, but you’ll get a warning.
	
	Generating a Secret Number
		through rand crate
			modify Cargo.toml file to include rand crate as a dependency.
				under [dependencies]

		use rand::Rng;
			Rng is a trait. See Chapter 10 for more info.
		let secret_number = rand::thread_rng().gen_range(1, 101);
			
		println!("The secret number is: {}", secret_number);
		
	Comparing the Guess to the Secret Number
		std::cmp::Ordering
			Ordering is an enum
			
		match guess.cmp(&secret_number) {
			Ordering::Less => println!("Too small!"),
			Ordering::Greater => println!("Too big!"),
			Ordering::Equal => println!("You win!"),
		}

			A match expression is made up of arms.
				An arm consists of pattern.
			
		let guess: u32 = guess.trim().parse().expect("Please type a number!");
			shadowing: is a solution for converting the type of the variable.
				in this case it was a String and became an integer.
				Shadowing lets us reuse the guess variable name rather than forcing us to create two unique variables, such as guess_str and guess for example.
			trim remove trailing space.
			parse get the number out of the string.
			
			** IMPORTANT:
				Notice we didn't declare the secret_number type; it's the job of the cmp method to infer that.
			expect:
				print error mesage.
			
			
	Allowing Multiple Guesses with Looping
		The loop keyword creates an infinite loop.
		We’ll add that now to give users more chances at guessing the number:
		    loop {
				println!("Please input your guess.");


				match guess.cmp(&secret_number) {
					Ordering::Less => println!("Too small!"),
					Ordering::Greater => println!("Too big!"),
					Ordering::Equal => println!("You win!"),
					
					    }
					}
					
	Handling Invalid Input
		Switching from an expect call to a match expression is how you generally move from crashing on an error to handling the error.
		
			let guess: u32 = match guess.trim().parse() {
				Ok(num) => num,
				Err(_) => continue,
			};
				
		Remember that parse returns a Result type and Result is an enum that has the variants Ok or Err.
		

3. Common Programming Concepts
	Introduction:
		Keywords:
			variables \ basic types \ functions \ comments \ control flow
	Questions:
		Question 3.1.1
		We didn't we use [let] keyword here, why? When is that possible?
	
	Concepts:
		Panic \ Integer Overflow \ Function’s Signature
		
	3.1. Variables and Mutability
		By default variables are immutable.
			Safety + Concurrency.
		In Rust, the compiler guarantees that when you state that a value won’t change, it really won’t change.
		You can make variables mutable by adding [mut] in front of the variable name.
			In addition to allowing this value to change, mut conveys intent to future readers of the code by indicating that other parts of the code will be changing this variable’s value.
			
			fn main() {
				let mut x = 5;
				println!("The value of x is: {}", x);
				x = 6; // Question 3.1.1 <<<
				println!("The value of x is: {}", x);
				}
		
		Differences Between Variables and Constants:
			First, you aren’t allowed to use mut with constants. Constants aren’t just immutable by default—they’re always immutable.
			
			You declare constants using the const keyword instead of the let keyword.
			
			The type of the value must be annotated. // See Next Section [3.2. Data Types].
			
			Constants can be declared in any scope, including the global scope, which makes them useful for values that many parts of code need to know about.
			
			const MAX_POINTS: u32 = 100_000;
			
			Constants are valid for the entire time a program runs, within the scope they were declared in, making them a useful choice for values in your application domain that multiple parts of the program might need to know about, such as the maximum number of points any player of a game is allowed to earn or the speed of light.
			
		Shadowing:
			you can declare a new variable with the same name as a previous variable, and the new variable shadows the previous variable. 
			
			fn main() {
				let x = 5;

				let x = x + 1;

				let x = x * 2;

				println!("The value of x is: {}", x);
			}
			
				// The final value of x is 12.
			
			Shadowing is different from marking a variable as mut, because we’ll get a compile-time error if we accidentally try to reassign to this variable without using the let keyword. 
			
			Shadowing thus spares us from having to come up with different names, such as spaces_str and spaces_num; instead, we can reuse the simpler spaces name. 
			

	3.2. Data Types
		Keep in mind that Rust is a statically typed language, which means that it must know the types of all variables at compile time. 
		
		Two data type subsets: 
			scalar
				Integers
					[u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize]
					(_) underscore can be used as a sperator 1_054_00
					default i32
				Floating-Point
					[f32, f64]
					default f64
				Booleans
					[true, false]
				Characters
					declared using single quote 'some_string'
					single character ... not more than one UTF-8!
					
					fn main() {
						let c = 'z';
						let z = 'ℤ';
						let heart_eyed_cat = '😻';
					}

			compound
				Compound types can group multiple values into one type. Rust has two primitive compound types: tuples and arrays.
				
				The Tuple Type:
					A tuple is a general way of grouping together a number of values with a variety of types into one compound type.
					
					Tuples have a fixed length: once declared, they cannot grow or shrink in size.
					
					We create a tuple by writing a comma-separated list of values inside parentheses.
					
					Each position in the tuple has a type, and the types of the different values in the tuple don’t have to be the same.
					
					fn main() {
						let tup: (i32, f64, u8) = (500, 6.4, 1);
					}
						
					fn main() {
						let tup = (500, 6.4, 1);
						let (x, y, z) = tup;
						println!("The value of y is: {}", y);
					}
					
					In addition to destructuring through pattern matching, we can access a tuple element directly by using a period (.) followed by the index of the value we want to access. 
					
					fn main() {
						let x: (i32, f64, u8) = (500, 6.4, 1);
						let five_hundred = x.0;
						let six_point_four = x.1;
						let one = x.2;
					}
					

				The Array Type:
					Unlike a tuple, every element of an array must have the same type.
					
					Arrays in Rust are different from arrays in some other languages because arrays in Rust have a fixed length, like tuples.
					
					In Rust, the values going into an array are written as a comma-separated list inside square brackets:
					
					fn main() {
						let a = [1, 2, 3, 4, 5];
					}
					
					Arrays are useful when you want your data allocated on the stack rather than the heap,
					
					or when you want to ensure you always have a fixed number of elements.
					
					An array isn’t as flexible as the vector type, though. A vector is a similar collection type provided by the standard library that is allowed to grow or shrink in size.
					
					 If you’re unsure whether to use an array or a vector, you should probably use a vector. 
					 
					 Chapter 8 discusses vectors in more detail.
					
					An example of when you might want to use an array rather than a vector is in a program that needs to know the names of the months of the year. 
					
					fn main() {
						let months = ["January", "February", "March", "April", "May", "June", "July",
						"August", "September", "October", "November", "December"];
					}
					
					You would write an array’s type by using square brackets, and within the brackets include the type of each element, a semicolon, and then the number of elements in the array, like so:
					
					fn main() {
						let a: [i32; 5] = [1, 2, 3, 4, 5];
					}
					
						Here, i32 is the type of each element. After the semicolon, the number 5 indicates the array contains five elements.
					
					fn main() {
						let a = [3; 5];
					}
					
						The array named a will contain 5 elements that will all be set to the value 3 initially. This is the same as writing let a = [3, 3, 3, 3, 3]; but in a more concise way.
						
					An array is a single chunk of memory allocated on the stack. You can access elements of an array using indexing, like this:
					
					fn main() {
						let a = [1, 2, 3, 4, 5];
						let first = a[0];
						let second = a[1];
						}
				

	3.3. Functions
		[main] function is the entry point of [many] programs in Rust.
		
		functions are declared using [fn] keyword.
		
		snake_case convention is used to name functions.
			
		fn main() {
			println!("Hello, world!");

			another_function();
		}

		fn another_function() {
			println!("Another function.");
		}
		
		Function definitions in Rust start with fn and have a set of parentheses after the function name.
		
		The curly brackets tell the compiler where the function body begins and ends.
		
		Rust doesn’t care where you define your functions, only that they’re defined somewhere.
		
		Function Parameters:
			Functions can also be defined to have parameters, which are special variables that are part of a function’s signature.
			
			When a function has parameters, you can provide it with concrete values for those parameters.
				Technically, the concrete values are called arguments.
				
			fn main() {
				another_function(5);
			}

			fn another_function(x: i32) {
				println!("The value of x is: {}", x);
			}
			
			##########
			In function signatures, you must declare the type of each parameter.
			##########
			
		Function Bodies Contain Statements and Expressions:
			Basic stuff.
			
		Functions with Return Values:
			You can return early from a function by using the return keyword and specifying a value, but most functions return the last expression implicitly.
			
			fn main() {
				let x = plus_one(5);

				println!("The value of x is: {}", x);
				}

			fn plus_one(x: i32) -> i32 {
				x + 1
			}

	3.4. Comments
		Double Slash // is the basic type of comments.
			// Double slash can be used on at the beginning of the line or at the end.
		
	3.5. Control Flow
		if expressions:
			fn main() {
				let number = 3;

				if number < 5 {
					println!("condition was true");
				}
				else {
					println!("condition was false");
				}
			}
			
			Blocks of code associated with the conditions in if expressions are sometimes called arms, just like the arms in match expressions.
			
			Optionally, we can also include an else expression.
			
			If you don’t provide an else expression and the condition is false, the program will just skip the if block and move on to the next bit of code.
			
			It’s also worth noting that the condition in this code must be a bool.
				Compare that to other programming languages; like python!
				
		Handling Multiple Conditions with else if:
			fn main() {
				let number = 6;

				if number % 4 == 0 {
					println!("number is divisible by 4");
				} 
				else if number % 3 == 0 {
					println!("number is divisible by 3");
				} // This is the condition that will be executed.
				else if number % 2 == 0 {
					println!("number is divisible by 2");
				} 
				else {
					println!("number is not divisible by 4, 3, or 2");
				}
			}
			
			Rust only executes the block for the first true condition, and once it finds one, it doesn’t even check the rest.
			
			Using too many else if expressions can clutter your code, so if you have more than one, you might want to refactor your code. Chapter 6 describes a powerful Rust branching construct called match for these cases.
		
		Using if in a let Statement:
			Because if is an expression, we can use it on the right side of a let statement:
				fn main() {
					let condition = true;
					let number = if condition { 5 } else { 6 };

					println!("The value of number is: {}", number);
				}
				
					Remember that blocks of code evaluate to the last expression in them, and numbers by themselves are also expressions.
					
			

		Repetition with Loops:
			Rust has three kinds of loops: 
				loop
				while
				for
			
		Returning Values from Loops:
			Using break expression.
			fn main() {
				let mut counter = 0;

				let result = loop {
					counter += 1;

					if counter == 10 {
						break counter * 2;
					}
				};

				println!("The result is {}", result);
			}

		Conditional Loops with while:
			fn main() {
				let mut number = 3;

				while number != 0 {
					println!("{}!", number);

					number -= 1;
				}

				println!("LIFTOFF!!!");
			}
		
		Looping Through a Collection with for:
		
			fn main() {
				let a = [10, 20, 30, 40, 50];

				for element in a.iter() {
					println!("the value is: {}", element);
				}
			}

		
4. Understanding Ownership
	Ownership is Rust’s most unique feature, and it enables Rust to make memory safety guarantees without needing a garbage collector. 
	
	Also discussed:
		borrowing \ slices \ memory management \ references \ data races \ mutable references \ lifetime \
	
	4.1. What is Ownership?
		Rust’s central feature is ownership. 
			Straightforward to explain.
			Yet deep implications.
		
		Memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. 
		
		Stack vs. Heap:
			In a systems programming language like Rust, whether a value is on the stack or the heap has more of an effect on how the language behaves and why you have to make certain decisions. 
			
			Both the stack and the heap are parts of memory that are available to your code to use at runtime, but they are structured in different ways. 
			
			The stack stores values in the order it gets them and removes the values in the opposite order. This is referred to as last in, first out.
				Stack ... like a stack of plates LIFO.
			
				Adding data is called pushing onto the stack, and removing data is called popping off the stack.
				
				All data stored on the stack must have a known, fixed size.
			
			Data with an unknown size at compile time or a size that might change must be stored on the heap instead.
			
			The heap is less organized: when you put data on the heap, you request a certain amount of space. 
			
			The memory allocator finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer, which is the address of that location. 
			
				This process is called allocating on the heap and is sometimes abbreviated as just allocating. 
				
			Think of being seated at a restaurant. When you enter, you state the number of people in your group, and the staff finds an empty table that fits everyone and leads you there.
			
				 If someone in your group comes late, they can ask where you’ve been seated to find you. [POINTER].
			
			Pushing to the stack is faster than allocating on the heap because the allocator never has to search for a place to store new data; that location is always at the top of the stack.
			
			Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. 
			
		Ownership Rules:
			Each value in Rust has a variable that’s called its owner.
			There can only be one owner at a time.
			When the owner goes out of scope, the value will be dropped.
	
		Variable Scope:
			A scope is the range within a program for which an item is valid.

			fn main() {
				{                      // s is not valid here, it’s not yet declared
					let s = "hello";   // s is valid from this point forward

					// do stuff with s
				}                      // this scope is now over, and s is no longer valid
			}
			
			There are two important points in time here:
				When s comes into scope, it is valid.
				It remains valid until it goes out of scope.
				
				At this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. 
				
				Now we’ll build on top of this understanding by introducing the String type.
			
		The String Type:
			String type is allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time.
			
			You can create a String from a string literal using the from function, like so:
			
			fn main() {
				let s = String::from("hello");
			}
			
			
			fn main() {
				let mut s = String::from("hello");

				s.push_str(", world!"); // push_str() appends a literal to a String

				println!("{}", s); // This will print `hello, world!`
			}
			
			So, what’s the difference here? Why can String be mutated but literals cannot? The difference is how these two types deal with memory.
			
		Memory and Allocation:
			In the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable.
			
			This is why string literals are fast and efficient. But these properties only come from the string literal’s immutability. 
			
			With the String type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:
			
				The memory must be requested from the memory allocator at runtime.
				
					That first part is done by us: when we call String::from, its implementation requests the memory it needs. This is pretty much universal in programming languages.

				We need a way of returning this memory to the allocator when we’re done with our String.
					Rust takes a different path from other programming languages that use Garbage Collector (GC),  the memory is automatically returned once the variable that owns it goes out of scope. Here’s a version of our scope example from Listing 4-1 using a String instead of a string literal:


				fn main() {
					{
						let s = String::from("hello"); // s is valid from this point forward

						// do stuff with s
					}                                  // this scope is now over, and s is no
													   // longer valid
				}

			When a variable goes out of scope, Rust automatically calls the drop function and cleans up the heap memory for that variable. 
			

			
		Ways Variables and Data Interact: Clone
			If we do want to deeply copy the heap data of the String, not just the stack data, we can use a common method called clone.
			
			fn main() {
				let s1 = String::from("hello");
				let s2 = s1.clone();

				println!("s1 = {}, s2 = {}", s1, s2);
			}

			When you see a call to clone, you know that some arbitrary code is being executed and that code may be expensive. It’s a visual indicator that something different is going on.
			
		Stack-Only Data: Copy
			Rust has a special annotation called the Copy trait that we can place on types like integers that are stored on the stack
			
		So what types implement the Copy trait? 
			All the integer types, such as u32.
			The Boolean type, bool, with values true and false.
			All the floating point types, such as f64.
			The character type, char.
			Tuples, if they only contain types that also implement Copy.
			
		Ownership and Functions:
			For the following code; try printing the value of s and x. Why do we get a compile error when we print s, but not x?
			
			fn main() {
				let s = String::from("hello");  // s comes into scope

				takes_ownership(s);             // s's value moves into the function...
												// ... and so is no longer valid here

				let x = 5;                      // x comes into scope

				makes_copy(x);                  // x would move into the function,
												// but i32 is Copy, so it’s okay to still
												// use x afterward

			} // Here, x goes out of scope, then s. But because s's value was moved, nothing
			  // special happens.

			fn takes_ownership(some_string: String) { // some_string comes into scope
				println!("{}", some_string);
			} // Here, some_string goes out of scope and `drop` is called. The backing
			  // memory is freed.

			fn makes_copy(some_integer: i32) { // some_integer comes into scope
				println!("{}", some_integer);
			} // Here, some_integer goes out of scope. Nothing special happens.

			If we print s we get the following error for s which is of the String type:
				[value borrowed here after move]
			But we don't get that error for x which is of the integer type.
			
		Return Values and Scope
			# The motive behind references & borrowing it seems. See the next section.

	4.2. References and Borrowing:
		& Symbole (Ampersand) denotes references (a pointer in other languages).
		These ampersands are references, and they allow you to refer to some value without taking ownership of it.
		
		fn main() {
			let s1 = String::from("hello");

			let s2 = &s1;

			println!("s1 = {}, s2 = {}", s1, s2);
			// s1 is the owner of the data "hello".
			// s2 is a reference, that referes to / points to the same data.
		}
		
		
		Note: The opposite of referencing by using & is dereferencing, which is accomplished with the dereference operator, *. We’ll see some uses of the dereference operator in Chapter 8 and discuss details of dereferencing in Chapter 15.
		
							& vs * ---- [Referencing (7) vs Dereferencing (8)]
		fn main() {
			let s1 = String::from("hello");

			let len = calculate_length(&s1);

			println!("The length of '{}' is {}.", s1, len);
		}

		fn calculate_length(s: &String) -> usize {
			s.len()
		}
		
			The &s1 syntax lets us create a reference that refers to the value of s1 but does not own it. 
			
			Because it does not own it, the value it points to will not be dropped when the reference goes out of scope.
			
			The scope in which the variable s is valid is the same as any function parameter’s scope, but we don’t drop what the reference points to when it goes out of scope because we don’t have ownership.
			
			When functions have references as parameters instead of the actual values, we won’t need to return the values in order to give back ownership, because we never had ownership.
			
			We call having references as function parameters borrowing.
			
			Watch the following video from Garry Explains YT channel:
				https://youtu.be/79phqVpE7cU
				
			Each bit of data, e.g. "hello", has an owner.
			And, there can be only one.
		
		
			We call having references as function parameters borrowing. As in real life, if a person owns something, you can borrow it from them. When you’re done, you have to give it back.
			
			** IMPORTANT:
			Just as variables are immutable by default, so are references. We’re not allowed to modify something we have a reference to.


		Mutable References:
			Mutable references have one big restriction: you can have only one mutable reference to a particular piece of data in a particular scope. 
			
			The benefit of having this restriction is that Rust can prevent data races at compile time. A data race is similar to a race condition and happens when these three behaviors occur:

				*	Two or more pointers access the same data at the same time.
				*	At least one of the pointers is being used to write to the data.
				*	There’s no mechanism being used to synchronize access to the data.
				
			As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not simultaneous ones:
			
			fn main() {
				let mut s = String::from("hello");

				{
					let r1 = &mut s;
				} // r1 goes out of scope here, so we can make a new reference with no problems.

				let r2 = &mut s;
			}
		
			We also cannot have a mutable reference while we have an immutable one.

			For instance, this code will compile because the last usage of the immutable references occurs before the mutable reference is introduced:
				
				fn main() {
					let mut s = String::from("hello");

					let r1 = &s; // no problem
					let r2 = &s; // no problem
					println!("{} and {}", r1, r2);
					// r1 and r2 are no longer used after this point

					let r3 = &mut s; // no problem
					println!("{}", r3);
				}

				The scopes of the immutable references r1 and r2 end after the println! where they are last used, which is before the mutable reference r3 is created. These scopes don’t overlap, so this code is allowed.


		Dangling References:
			In Rust, by contrast to other low-level languages, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.

		The Rules of References:
			At any given time, you can have either one mutable reference or any number of immutable references.
			References must always be valid.

		
	4.3. The Slice Type
		Slice is a a data type that does not have ownership.
		Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection.
		
		String Slices:
			A string slice is a reference to part of a String, and it looks like this:
				fn main() {
					let s = String::from("hello world");

					let hello = &s[0..5];
					let world = &s[6..11];
				}



		
5. Using Structs to Structure Related Data
	A struct, or structure, is a custom data type that lets you name and package together multiple related values that make up a meaningful group.
	
	If you’re familiar with an object-oriented language, a struct is like an object’s data attributes.
	
	Structs and enums (discussed in Chapter 6) are the building blocks for creating new types in your program’s domain to take full advantage of Rust’s compile time type checking.

	5.1. Defining and Instantiating Structs
		Structs consists of field which should be defined (types).
		
		Structs are similar to tuples, which were discussed in Chapter 3. Like tuples, the pieces of a struct can be different types. 
		
		Unlike with tuples, you’ll name each piece of data so it’s clear what the values mean.
		
		As a result of these names, structs are more flexible than tuples: you don’t have to rely on the order of the data to specify or access the values of an instance.
		
		To define a struct, we enter the keyword struct and name the entire struct. 
		
		Example:
			struct User {
				username: String,
				email: String,
				sign_in_count: u64,
				active: bool,
			}

			fn main() {}
			
		To use a struct after we’ve defined it, we create an instance of that struct by specifying concrete values for each of the fields.
		
		Creating Instances From Other Instances With Struct Update Syntax:
			Using:	[Double Dots ..]
			The syntax .. specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.

		Using Tuple Structs without Named Fields to Create Different Types:
			Tuple Structs just have the types of the fields.
			
			Example of tuple struct:
				fn main() {
					struct Color(i32, i32, i32);
					struct Point(i32, i32, i32);

					let black = Color(0, 0, 0);
					let origin = Point(0, 0, 0);
					
					println!("x is = {}", origin.0);
					println!("green is = {}", black.1);
				}

			tuple struct instances behave like tuples: you can destructure them into their individual pieces, you can use a . followed by the index to access an individual value, and so on.

	5.2. An Example Program Using Structs
		A program to calculate the area of a rectangle.
		
	5.3. Method Syntax
		Methods are similar to functions: 
		they’re declared with the fn keyword and their name, 
		they can have parameters and a return value, and they contain some code that is run when they’re called from somewhere else.
			
		However, methods are different from functions in that they’re defined within the context of a struct (or an enum or a trait object, which we cover in Chapters 6 and 17, respectively), 
		
		and their first parameter is always self, which represents the instance of the struct the method is being called on.
	
		Defining Methods:
			To define the function within the context of a struct (Rectangle in this example), we start an impl (implementation) block.
			
			Then we move the area function within the impl curly brackets and change the first (and in this case, only) parameter to be self in the signature and everywhere within the body. 

			
		
		
6. Enums and Pattern Matching
	Keywords:
		Option \ match \ if let \ generic types <T> \ None \ Some \ 
	
	Enums allow you to define a type by enumerating its possible variants. 
	
	6.1. Defining an Enum
		The following code using structs can be expressed using enums:
		-------------------------------------
			struct QuitMessage; // unit struct
			struct MoveMessage {
				x: i32,
				y: i32,
			}
			struct WriteMessage(String); // tuple struct
			struct ChangeColorMessage(i32, i32, i32); // tuple struct

			fn main() {}
		-------------------------------------

		-------------------------------------
			enum Message {
				Quit,
				Move { x: i32, y: i32 },
				Write(String),
				ChangeColor(i32, i32, i32),
			}

			fn main() {}
		-------------------------------------
		
		But if we used the different structs, which each have their own type, we couldn’t as easily define a function to take any of these kinds of messages as we could with the Message enum
		
		There is one more similarity between enums and structs: just as we’re able to define methods on structs using impl, we’re also able to define methods on enums. 
		
		The Option Enum and Its Advantages Over Null Values:
			The Option<T> enum is still just a regular enum, and Some(T) and None are still variants of type Option<T>.
			
			The <T> syntax is a feature of Rust we haven’t talked about yet. It’s a generic type parameter, and we’ll cover generics in more detail in Chapter 10.
			
			Not having to worry about incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value Option<T>.
			
			
	6.2. The match Control Flow Operator
		Rust has an extremely powerful control flow operator called match that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. 
		
		Patterns can be made up of literal values, variable names, wildcards, and many other things; Chapter 18 covers all the different kinds of patterns and what they do.
		
		The power of match comes from the expressiveness of the patterns and the fact that the compiler confirms that all possible cases are handled.
		
		Example of match expression combined with enums:
		-------------------------------------
			enum Coin {
				Penny,
				Nickel,
				Dime,
				Quarter,
			}

			fn value_in_cents(coin: Coin) -> u8 {
				match coin {
					Coin::Penny => 1,
					Coin::Nickel => 5,
					Coin::Dime => 10,
					Coin::Quarter => 25,
				}
			}

			fn main() {
				let a = Coin::Dime;
				let b = value_in_cents(a);
				println!("b is a {}", b);
			}
		-------------------------------------
		Combining match and enums is useful in many situations. You’ll see this pattern a lot in Rust code: match against an enum, bind a variable to the data inside, and then execute code based on it. It’s a bit tricky at first, but once you get used to it, you’ll wish you had it in all languages. It’s consistently a user favorite.


		Matches Are Exhaustive:
			

		
	6.3. Concise Control Flow with if let
		Using if let means less typing, less indentation, and less boilerplate code. However, you lose the exhaustive checking that match enforces.
		
		-------------------------------------
			fn main() {
				let some_u8_value = Some(0u8);
				if let Some(3) = some_u8_value {
					println!("three");
				}
			}
		-------------------------------------
		
		Choosing between match and if let depends on what you’re doing in your particular situation and whether gaining conciseness is an appropriate trade-off for losing exhaustive checking.
		
		In other words, you can think of if let as syntax sugar for a match that runs code when the value matches one pattern and then ignores all other values.

		We can include an else with an if let. The block of code that goes with the else is the same as the block of code that would go with the _ case in the match expression that is equivalent to the if let and else. 
	
	
7. Managing Growing Projects with Packages, Crates, and Modules
	Terms:
		binary crates \ library crate \ external packages \ glob operator \ signatures of functions \ 
		
	Keywords:
		use \ pub \ as \ 
		
	As a project grows, you can organize code by splitting it into multiple modules and then multiple files. 
	
	A package can contain multiple binary crates and optionally one library crate. 
	
	Once you’ve implemented an operation, other code can call that code via the code’s public interface without knowing how the implementation works.
	
	The way you write code defines which parts are public for other code to use and which parts are private implementation details that you reserve the right to change. 
	
	
	7.1. Packages and Crates
		A crate is a binary or library. 
		
		A package is one or more crates that provide a set of functionality. A package contains a Cargo.toml file that describes how to build those crates.
		
		
		Several rules determine what a package can contain:
			 A package must contain zero or one library crates, and no more.
			 It can contain as many binary crates as you’d like, but it must contain at least one crate (either library or binary).
			 
	7.2. Defining Modules to Control Scope and Privacy
		Modules let us organize code within a crate into groups for readability and easy reuse.
		
		Modules also control the privacy of items, which is whether an item can be used by outside code (public) or is an internal implementation detail and not available for outside use (private).
		
		Example of a libray in Rust.
		Restaurant library example that is partitioned among front_of_house and back-side.
		
		Filename: src/lib.rs
		-------------------------------------
			mod front_of_house {
				mod hosting {
					fn add_to_waitlist() {}

					fn seat_at_table() {}
				}

				mod serving {
					fn take_order() {}

					fn serve_order() {}

					fn take_payment() {}
				}
			}
		-------------------------------------
		
		We define a module by starting with the mod keyword and then specify the name of the module (in this case, front_of_house) and place curly brackets around the body of the module.
		
		Inside modules, we can have other modules, as in this case with the modules hosting and serving.
		
		Earlier, we mentioned that src/main.rs and src/lib.rs are called crate roots.
			crate
			 └── front_of_house
				 ├── hosting
				 │   ├── add_to_waitlist
				 │   └── seat_at_table
				 └── serving
					 ├── take_order
					 ├── serve_order
					 └── take_payment

		The reason for their name is that the contents of either of these two files form a module named crate at the root of the crate’s module structure, known as the module tree.
		
		Notice that the entire module tree is rooted under the implicit module named crate.

		The module tree might remind you of the filesystem’s directory tree on your computer; this is a very apt comparison! Just like directories in a filesystem, you use modules to organize your code. And just like files in a directory, we need a way to find our modules.

	7.3. Paths for Referring to an Item in the Module Tree
		
	7.4. Bringing Paths Into Scope with the use Keyword
	7.5. Separating Modules into Different Files
8. Common Collections
	8.1. Storing Lists of Values with Vectors
	8.2. Storing UTF-8 Encoded Text with Strings
	8.3. Storing Keys with Associated Values in Hash Maps
9. Error Handling
	9.1. Unrecoverable Errors with panic!
	9.2. Recoverable Errors with Result
	9.3. To panic! or Not To panic!
10. Generic Types, Traits, and Lifetimes
	10.1. Generic Data Types
	10.2. Traits: Defining Shared Behavior
	10.3. Validating References with Lifetimes
11. Writing Automated Tests
	11.1. How to Write Tests
	11.2. Controlling How Tests Are Run
	11.3. Test Organization
12. An I/O Project: Building a Command Line Program
	12.1. Accepting Command Line Arguments
	12.2. Reading a File
	12.3. Refactoring to Improve Modularity and Error Handling
	12.4. Developing the Library’s Functionality with Test Driven Development
	12.5. Working with Environment Variables
	12.6. Writing Error Messages to Standard Error Instead of Standard Output
13. Functional Language Features: Iterators and Closures
	13.1. Closures: Anonymous Functions that Can Capture Their Environment
	13.2. Processing a Series of Items with Iterators
	13.3. Improving Our I/O Project
	13.4. Comparing Performance: Loops vs. Iterators
14. More about Cargo and Crates.io
	14.1. Customizing Builds with Release Profiles
	14.2. Publishing a Crate to Crates.io
	14.3. Cargo Workspaces
	14.4. Installing Binaries from Crates.io with cargo install
	14.5. Extending Cargo with Custom Commands
15. Smart Pointers
	15.1. Using Box<T> to Point to Data on the Heap
	15.2. Treating Smart Pointers Like Regular References with the Deref Trait
	15.3. Running Code on Cleanup with the Drop Trait
	15.4. Rc<T>, the Reference Counted Smart Pointer
	15.5. RefCell<T> and the Interior Mutability Pattern
	15.6. Reference Cycles Can Leak Memory
16. Fearless Concurrency
	16.1. Using Threads to Run Code Simultaneously
	16.2. Using Message Passing to Transfer Data Between Threads
	16.3. Shared-State Concurrency
	16.4. Extensible Concurrency with the Sync and Send Traits
17. Object Oriented Programming Features of Rust
	17.1. Characteristics of Object-Oriented Languages
	17.2. Using Trait Objects That Allow for Values of Different Types
	17.3. Implementing an Object-Oriented Design Pattern
18. Patterns and Matching
	18.1. All the Places Patterns Can Be Used
	18.2. Refutability: Whether a Pattern Might Fail to Match
	18.3. Pattern Syntax
19. Advanced Features
	19.1. Unsafe Rust
	19.2. Advanced Traits
	19.3. Advanced Types
	19.4. Advanced Functions and Closures
	19.5. Macros
20. Final Project: Building a Multithreaded Web Server
	20.1. Building a Single-Threaded Web Server
	20.2. Turning Our Single-Threaded Server into a Multithreaded Server
	20.3. Graceful Shutdown and Cleanup
21. Appendix
	21.1. A - Keywords
	21.2. B - Operators and Symbols
	21.3. C - Derivable Traits
	21.4. D - Useful Development Tools
	21.5. E - Editions
	21.6. F - Translations of the Book
	21.7. G - How Rust is Made and “Nightly Rust”