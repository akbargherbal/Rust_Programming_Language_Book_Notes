The Rust Programming Language
Foreword
Introduction
1. Getting Started
	1.1. Installation
	
		Make sure you installed rust-analyzer plugin both in vs code or intelliJ Idea.
			Very useful for debugging!
			
	1.2. Hello, World!
	1.3. Hello, Cargo!
2. Programming a Guessing Game
	Introdution:
		Keywords:
			let \ match \ use \ fn \ mut \ & \
			
		Concepts:
			crate \ shadowing \ Result type \ ok  \ Err
			
			expression will result in a value; e.g. 5 or True or Err
			Statement is the reverse of expression.
			
			Statements are instructions that do something, they don‚Äôt return a value. Expressions evaluate to a value, they return that value.
			
			Rust is an expression-oriented language. This means that most things are expressions, and evaluate to some kind of value. However, there are also statements.
			
			A function definition is a statement, it does not result in a value. Calling a function is an expression, that expression evaluates to whatever that function call returns.
			
			let num = add(4, 1); // expression that returns a value; 5.

			fn add(x: i32, y:i32) -> i32 {
				x + y
			} // Function definition is a statement that doesn't evaluate to anything.
				On the other hand, calling a function is an expression.
			
			let y = 6; // This is a statement.
			
			########
			Expressions do not include ending semicolons. 
			########




		Goal:
			Generate a random number between 1 - 100.
				Print a congratulatory message.
		Tips:
			cargo doc --open
				open crate documentation in browser.
		Questions:
			Why the current version of the rand crate did not compile; contrary to the old one?
			
	use std::io;
		Import Input/Output from the standard library [std]
		
	fn main() {}
		The entry point to the program.
		
	let mut guess = String::new();
		let:	Create a variable.
		let mut guess:	 explicitly declare the variable guess to be mutible.
		String::new();	A static method; implement method on the class not the instance.
		The :: syntax in the ::new line indicates that new is an associated function (Agains static mehtod).
		
	io::stdin().read_line(&mut guess)
		& indicates that this argument is a reference.
			See Chapter 4 to understand references in Rust.
		.expect("Failed to read line");
			Handling Potential Failure with the Result Type
				See Chapters 6 and 9 for more details on errors.
			If you don‚Äôt call expect, the program will compile, but you‚Äôll get a warning.
	
	Generating a Secret Number
		through rand crate
			modify Cargo.toml file to include rand crate as a dependency.
				under [dependencies]

		use rand::Rng;
			Rng is a trait. See Chapter 10 for more info.
		let secret_number = rand::thread_rng().gen_range(1, 101);
			
		println!("The secret number is: {}", secret_number);
		
	Comparing the Guess to the Secret Number
		std::cmp::Ordering
			Ordering is an enum
			
		match guess.cmp(&secret_number) {
			Ordering::Less => println!("Too small!"),
			Ordering::Greater => println!("Too big!"),
			Ordering::Equal => println!("You win!"),
		}

			A match expression is made up of arms.
				An arm consists of pattern.
			
		let guess: u32 = guess.trim().parse().expect("Please type a number!");
			shadowing: is a solution for converting the type of the variable.
				in this case it was a String and became an integer.
				Shadowing lets us reuse the guess variable name rather than forcing us to create two unique variables, such as guess_str and guess for example.
			trim remove trailing space.
			parse get the number out of the string.
			
			IMPORTANT:
				Notice we didn't declare the secret_number type; it's the job of the cmp method to infer that.
			expect:
				print error mesage.
			
			
	Allowing Multiple Guesses with Looping
		The loop keyword creates an infinite loop.
		We‚Äôll add that now to give users more chances at guessing the number:
		    loop {
				println!("Please input your guess.");


				match guess.cmp(&secret_number) {
					Ordering::Less => println!("Too small!"),
					Ordering::Greater => println!("Too big!"),
					Ordering::Equal => println!("You win!"),
					
					    }
					}
					
	Handling Invalid Input
		Switching from an expect call to a match expression is how you generally move from crashing on an error to handling the error.
		
			let guess: u32 = match guess.trim().parse() {
				Ok(num) => num,
				Err(_) => continue,
			};
				
		Remember that parse returns a Result type and Result is an enum that has the variants Ok or Err.
		

3. Common Programming Concepts
	Introduction:
		Keywords:
			variables \ basic types \ functions \ comments \ control flow
	Questions:
		Question 3.1.1
		We didn't we use [let] keyword here, why? When is that possible?
	
	Concepts:
		Panic \ Integer Overflow \ Function‚Äôs Signature
		
	3.1. Variables and Mutability
		By default variables are immutable.
			Safety + Concurrency.
		In Rust, the compiler guarantees that when you state that a value won‚Äôt change, it really won‚Äôt change.
		You can make variables mutable by adding [mut] in front of the variable name.
			In addition to allowing this value to change, mut conveys intent to future readers of the code by indicating that other parts of the code will be changing this variable‚Äôs value.
			
			fn main() {
				let mut x = 5;
				println!("The value of x is: {}", x);
				x = 6; // Question 3.1.1 <<<
				println!("The value of x is: {}", x);
				}
		
		Differences Between Variables and Constants:
			First, you aren‚Äôt allowed to use mut with constants. Constants aren‚Äôt just immutable by default‚Äîthey‚Äôre always immutable.
			
			You declare constants using the const keyword instead of the let keyword.
			
			The type of the value must be annotated. // See Next Section [3.2. Data Types].
			
			Constants can be declared in any scope, including the global scope, which makes them useful for values that many parts of code need to know about.
			
			const MAX_POINTS: u32 = 100_000;
			
			Constants are valid for the entire time a program runs, within the scope they were declared in, making them a useful choice for values in your application domain that multiple parts of the program might need to know about, such as the maximum number of points any player of a game is allowed to earn or the speed of light.
			
		Shadowing:
			you can declare a new variable with the same name as a previous variable, and the new variable shadows the previous variable. 
			
			fn main() {
				let x = 5;

				let x = x + 1;

				let x = x * 2;

				println!("The value of x is: {}", x);
			}
			
				// The final value of x is 12.
			
			Shadowing is different from marking a variable as mut, because we‚Äôll get a compile-time error if we accidentally try to reassign to this variable without using the let keyword. 
			
			Shadowing thus spares us from having to come up with different names, such as spaces_str and spaces_num; instead, we can reuse the simpler spaces name. 
			

	3.2. Data Types
		Keep in mind that Rust is a statically typed language, which means that it must know the types of all variables at compile time. 
		
		Two data type subsets: 
			scalar
				Integers
					[u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize]
					(_) underscore can be used as a sperator 1_054_00
					default i32
				Floating-Point
					[f32, f64]
					default f64
				Booleans
					[true, false]
				Characters
					declared using single quote 'some_string'
					single character ... not more than one UTF-8!
					
					fn main() {
						let c = 'z';
						let z = '‚Ñ§';
						let heart_eyed_cat = 'üòª';
					}

			compound
				Compound types can group multiple values into one type. Rust has two primitive compound types: tuples and arrays.
				
				The Tuple Type:
					A tuple is a general way of grouping together a number of values with a variety of types into one compound type.
					
					Tuples have a fixed length: once declared, they cannot grow or shrink in size.
					
					We create a tuple by writing a comma-separated list of values inside parentheses.
					
					Each position in the tuple has a type, and the types of the different values in the tuple don‚Äôt have to be the same.
					
					fn main() {
						let tup: (i32, f64, u8) = (500, 6.4, 1);
					}
						
					fn main() {
						let tup = (500, 6.4, 1);
						let (x, y, z) = tup;
						println!("The value of y is: {}", y);
					}
					
					In addition to destructuring through pattern matching, we can access a tuple element directly by using a period (.) followed by the index of the value we want to access. 
					
					fn main() {
						let x: (i32, f64, u8) = (500, 6.4, 1);
						let five_hundred = x.0;
						let six_point_four = x.1;
						let one = x.2;
					}
					

				The Array Type:
					Unlike a tuple, every element of an array must have the same type.
					
					Arrays in Rust are different from arrays in some other languages because arrays in Rust have a fixed length, like tuples.
					
					In Rust, the values going into an array are written as a comma-separated list inside square brackets:
					
					fn main() {
						let a = [1, 2, 3, 4, 5];
					}
					
					Arrays are useful when you want your data allocated on the stack rather than the heap,
					
					or when you want to ensure you always have a fixed number of elements.
					
					An array isn‚Äôt as flexible as the vector type, though. A vector is a similar collection type provided by the standard library that is allowed to grow or shrink in size.
					
					 If you‚Äôre unsure whether to use an array or a vector, you should probably use a vector. 
					 
					 Chapter 8 discusses vectors in more detail.
					
					An example of when you might want to use an array rather than a vector is in a program that needs to know the names of the months of the year. 
					
					fn main() {
						let months = ["January", "February", "March", "April", "May", "June", "July",
						"August", "September", "October", "November", "December"];
					}
					
					You would write an array‚Äôs type by using square brackets, and within the brackets include the type of each element, a semicolon, and then the number of elements in the array, like so:
					
					fn main() {
						let a: [i32; 5] = [1, 2, 3, 4, 5];
					}
					
						Here, i32 is the type of each element. After the semicolon, the number 5 indicates the array contains five elements.
					
					fn main() {
						let a = [3; 5];
					}
					
						The array named a will contain 5 elements that will all be set to the value 3 initially. This is the same as writing let a = [3, 3, 3, 3, 3]; but in a more concise way.
						
					An array is a single chunk of memory allocated on the stack. You can access elements of an array using indexing, like this:
					
					fn main() {
						let a = [1, 2, 3, 4, 5];
						let first = a[0];
						let second = a[1];
						}
				

	3.3. Functions
		[main] function is the entry point of [many] programs in Rust.
		
		functions are declared using [fn] keyword.
		
		snake_case convention is used to name functions.
			
		fn main() {
			println!("Hello, world!");

			another_function();
		}

		fn another_function() {
			println!("Another function.");
		}
		
		Function definitions in Rust start with fn and have a set of parentheses after the function name.
		
		The curly brackets tell the compiler where the function body begins and ends.
		
		Rust doesn‚Äôt care where you define your functions, only that they‚Äôre defined somewhere.
		
		Function Parameters:
			Functions can also be defined to have parameters, which are special variables that are part of a function‚Äôs signature.
			
			When a function has parameters, you can provide it with concrete values for those parameters.
				Technically, the concrete values are called arguments.
				
			fn main() {
				another_function(5);
			}

			fn another_function(x: i32) {
				println!("The value of x is: {}", x);
			}
			
			##########
			In function signatures, you must declare the type of each parameter.
			##########
			
		Function Bodies Contain Statements and Expressions:
			Basic stuff.
			
		Functions with Return Values:
			You can return early from a function by using the return keyword and specifying a value, but most functions return the last expression implicitly.
			
			fn main() {
				let x = plus_one(5);

				println!("The value of x is: {}", x);
				}

			fn plus_one(x: i32) -> i32 {
				x + 1
			}

	3.4. Comments
		Double Slash // is the basic type of comments.
			// Double slash can be used on at the beginning of the line or at the end.
		
	3.5. Control Flow
		if expressions:
			fn main() {
				let number = 3;

				if number < 5 {
					println!("condition was true");
				}
				else {
					println!("condition was false");
				}
			}
			
			Blocks of code associated with the conditions in if expressions are sometimes called arms, just like the arms in match expressions.
			
			Optionally, we can also include an else expression.
			
			If you don‚Äôt provide an else expression and the condition is false, the program will just skip the if block and move on to the next bit of code.
			
			It‚Äôs also worth noting that the condition in this code must be a bool.
				Compare that to other programming languages; like python!
				
		Handling Multiple Conditions with else if:
			fn main() {
				let number = 6;

				if number % 4 == 0 {
					println!("number is divisible by 4");
				} 
				else if number % 3 == 0 {
					println!("number is divisible by 3");
				} // This is the condition that will be executed.
				else if number % 2 == 0 {
					println!("number is divisible by 2");
				} 
				else {
					println!("number is not divisible by 4, 3, or 2");
				}
			}
			
			Rust only executes the block for the first true condition, and once it finds one, it doesn‚Äôt even check the rest.
			
			Using too many else if expressions can clutter your code, so if you have more than one, you might want to refactor your code. Chapter 6 describes a powerful Rust branching construct called match for these cases.
		
		Using if in a let Statement:
			Because if is an expression, we can use it on the right side of a let statement:
				fn main() {
					let condition = true;
					let number = if condition { 5 } else { 6 };

					println!("The value of number is: {}", number);
				}
				
					Remember that blocks of code evaluate to the last expression in them, and numbers by themselves are also expressions.
					
			

		Repetition with Loops:
			Rust has three kinds of loops: 
				loop
				while
				for
			
		Returning Values from Loops:
			Using break expression.
			fn main() {
				let mut counter = 0;

				let result = loop {
					counter += 1;

					if counter == 10 {
						break counter * 2;
					}
				};

				println!("The result is {}", result);
			}

		Conditional Loops with while:
			fn main() {
				let mut number = 3;

				while number != 0 {
					println!("{}!", number);

					number -= 1;
				}

				println!("LIFTOFF!!!");
			}
		
		Looping Through a Collection with for:
		
			fn main() {
				let a = [10, 20, 30, 40, 50];

				for element in a.iter() {
					println!("the value is: {}", element);
				}
			}

		
4. Understanding Ownership
	4.1. What is Ownership?
	4.2. References and Borrowing
	4.3. The Slice Type
5. Using Structs to Structure Related Data
	5.1. Defining and Instantiating Structs
	5.2. An Example Program Using Structs
	5.3. Method Syntax
6. Enums and Pattern Matching
	6.1. Defining an Enum
	6.2. The match Control Flow Operator
	6.3. Concise Control Flow with if let
7. Managing Growing Projects with Packages, Crates, and Modules
	7.1. Packages and Crates
	7.2. Defining Modules to Control Scope and Privacy
	7.3. Paths for Referring to an Item in the Module Tree
	7.4. Bringing Paths Into Scope with the use Keyword
	7.5. Separating Modules into Different Files
8. Common Collections
	8.1. Storing Lists of Values with Vectors
	8.2. Storing UTF-8 Encoded Text with Strings
	8.3. Storing Keys with Associated Values in Hash Maps
9. Error Handling
	9.1. Unrecoverable Errors with panic!
	9.2. Recoverable Errors with Result
	9.3. To panic! or Not To panic!
10. Generic Types, Traits, and Lifetimes
	10.1. Generic Data Types
	10.2. Traits: Defining Shared Behavior
	10.3. Validating References with Lifetimes
11. Writing Automated Tests
	11.1. How to Write Tests
	11.2. Controlling How Tests Are Run
	11.3. Test Organization
12. An I/O Project: Building a Command Line Program
	12.1. Accepting Command Line Arguments
	12.2. Reading a File
	12.3. Refactoring to Improve Modularity and Error Handling
	12.4. Developing the Library‚Äôs Functionality with Test Driven Development
	12.5. Working with Environment Variables
	12.6. Writing Error Messages to Standard Error Instead of Standard Output
13. Functional Language Features: Iterators and Closures
	13.1. Closures: Anonymous Functions that Can Capture Their Environment
	13.2. Processing a Series of Items with Iterators
	13.3. Improving Our I/O Project
	13.4. Comparing Performance: Loops vs. Iterators
14. More about Cargo and Crates.io
	14.1. Customizing Builds with Release Profiles
	14.2. Publishing a Crate to Crates.io
	14.3. Cargo Workspaces
	14.4. Installing Binaries from Crates.io with cargo install
	14.5. Extending Cargo with Custom Commands
15. Smart Pointers
	15.1. Using Box<T> to Point to Data on the Heap
	15.2. Treating Smart Pointers Like Regular References with the Deref Trait
	15.3. Running Code on Cleanup with the Drop Trait
	15.4. Rc<T>, the Reference Counted Smart Pointer
	15.5. RefCell<T> and the Interior Mutability Pattern
	15.6. Reference Cycles Can Leak Memory
16. Fearless Concurrency
	16.1. Using Threads to Run Code Simultaneously
	16.2. Using Message Passing to Transfer Data Between Threads
	16.3. Shared-State Concurrency
	16.4. Extensible Concurrency with the Sync and Send Traits
17. Object Oriented Programming Features of Rust
	17.1. Characteristics of Object-Oriented Languages
	17.2. Using Trait Objects That Allow for Values of Different Types
	17.3. Implementing an Object-Oriented Design Pattern
18. Patterns and Matching
	18.1. All the Places Patterns Can Be Used
	18.2. Refutability: Whether a Pattern Might Fail to Match
	18.3. Pattern Syntax
19. Advanced Features
	19.1. Unsafe Rust
	19.2. Advanced Traits
	19.3. Advanced Types
	19.4. Advanced Functions and Closures
	19.5. Macros
20. Final Project: Building a Multithreaded Web Server
	20.1. Building a Single-Threaded Web Server
	20.2. Turning Our Single-Threaded Server into a Multithreaded Server
	20.3. Graceful Shutdown and Cleanup
21. Appendix
	21.1. A - Keywords
	21.2. B - Operators and Symbols
	21.3. C - Derivable Traits
	21.4. D - Useful Development Tools
	21.5. E - Editions
	21.6. F - Translations of the Book
	21.7. G - How Rust is Made and ‚ÄúNightly Rust‚Äù